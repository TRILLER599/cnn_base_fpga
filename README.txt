
    SV-КОД НЕЙРОСЕТИ ЕЩЁ НЕ ВЫЛОЖЕН! ВНОШУ ИЗМЕНЕНИЯ В СТОРОНУ БОЛЕЕ ВПЕЧАТЛЯЮЩЕГО
    РЕЗУЛЬТАТА! КОД БУДЕТ ВЕЧЕРОМ 09.21

    Основная цель данного проекта - проверить возможность реализации системы 
обучения больших нейронных сетей(НС) на множестве ПЛИС для снижения времени 
обучения на порядок по сравнению с таковым на видеокартах.
    
    Центральная часть проекта - простая свёрточная нейросеть на FPGA с полностью
параллельными/конвейерными вычислениями. В представленном проекте используется
1 кристалл, но предполагается, что каждый слой/несколько слоев НС вычисляются
на отдельной микросхеме, а связь между слоями организована на высокоскоростных
приёмо-передатчиках(трансиверах) с простым интерфейсом на основе FIFO.
Вычисления уплотнены для переиспользования ресурсов, но в некоторых местах
они всё ещё не оптимальны. Впрочем, простор для исследований здесь широчайший.
После того, как будет сделано "внимание", придёт время для настоящей оптимизации.        
    Для осуществления обучения написан протокол обработки UDP-пакетов
на стороне ПЛИС и его клиентская часть для PC на python.
    Эта же нейросеть написана на numpy для запуска вычислений на процессоре
и контроля корректности FPGA-алгоритма.

    Я НЕ профессиональный программист - я "плисовод", поэтому не обессудьте))

    1. папка classInt16CNN
    В ней запускаемая на процессоре свёрточная нейросеть на голом numpy.
Исполнив в интерпетаторе classInt16CNN_Transfer_00_Base.py запустите обучение 
тёрхслойной свёрточной сети в течение 2 эпох - определено параметром EPOCHA
Перед этим необходимо разархивировать mnist_original_archive.zip в этой же папке.
Свёрточный и полносвязный слои описаны в conv_layer.py и fully_layer.py
Осторожно! Обучение 1 эпохи занимает около 15 минут.
Данные выводимые в консоль можно использовать для сравнения с обучением
аналогичной НС на ПЛИС. Внимание! Необходимо сохранять структуру каталогов
репозитория, так как "веса" и настройки класса classInt16CNN используются в
процессе обучения НС на ПЛИС. Столь мелкий размер сети обусловлен именно
долгой работой эталонной  модели, а не ресурсами ПЛИС.


    2. Каталог cnn_sv содержит исходники FPGA-проекта        
    Код не содержит примитивов, но был ориентирован на DSP от ксайлинкса. 
Впрочем, там ничего хитрого и проблем быть не должно и для альтеры и пр.
    
neural_network_top.sv (         - файл верхнего уровня.
    input clk,                  - частота нейронной сети, должна быть < clk_eth
    input clk_eth,              - частота Ethernet_10G = 312,5 МГц
    input i_eth_conf_complete,  - сигнал готовности Ethernet
    Остальные порты - стандартные RX и TX десяти гигабитной оптики
);
    
reti_neurali_base_0828.sv (                 - файл верхнего уровня нейросети
    В него заглядывать смысла нету. Генерируется из псевдо-С++ исходников
    собственным вариантом HLS, поэтому читаемость и воспринимаемость кода
    не на высоком уровне.
);
    
    3. Настройка соединения
    В настройках десяти гигабитной оптической сетевой карты должны быть включены
джамбо-фреймы! Протокол управления обучением использует UDP пакеты с максимальным
payload=8192 байта. IP-адрес FPGA установлен на 192.168.19.128 поэтому сетевая
карта должна быть в 19-й подсети. Реализованы только ответы на ARP-запросы и
команды обучения - лень было заморачиваться пока. 
К моменту начала обучения плата должна быть прошита и IP-адресу должен
соответствовать MAC=33:11:22:00:AA:BB. Надеюсь, найду время прикрутить ответ
на ping.


    4. scenario.py - реализует сценарий обучения НС на FPGA.
    Для запуска процесса обучения НС на ПЛИС следует исполнять именно его.
Использует класс classGestioneFunzionale и его методы из файла 
pyGestioneFunzionale.py, в котором реализован протокол обмена с ПЛИС.
classGestioneFunzionale извлекает "веса" и прочие изменяемые параметры из 
classInt16CNN, таким образом обеспечивается контроль корректности работы ПЛИС.
Сделан простейший эхо-клиент, а потому максимальная скорость обучения не 
достигается. Отсюда следует, что "водить" ПЛИС на максимальную частоту особого 
смысла нету - она всё равно будет простаивать. Вся мощь FPGA и весь сетевой
поток нужены для гораздо более серьёзных задач))
